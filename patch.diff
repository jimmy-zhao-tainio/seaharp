*** Begin Patch
*** Add File: Seaharp.Geometry.Predicates/BridgePredicates.cs
+using System;
+using System.Numerics;
+
+namespace Seaharp.Geometry.Predicates;
+
+public static class BridgePredicates
+{
+    private static readonly Int128 Zero = default;
+
+    // Local Int128 vector for exact orientation math.
+    private readonly record struct Int128Vector(Int128 X, Int128 Y, Int128 Z)
+    {
+        public static Int128Vector FromPoints(in Point origin, in Point target)
+            => new((Int128)target.X - (Int128)origin.X,
+                   (Int128)target.Y - (Int128)origin.Y,
+                   (Int128)target.Z - (Int128)origin.Z);
+
+        public static Int128Vector Cross(in Int128Vector a, in Int128Vector b)
+            => new(a.Y * b.Z - a.Z * b.Y,
+                   a.Z * b.X - a.X * b.Z,
+                   a.X * b.Y - a.Y * b.X);
+
+        public static Int128 Dot(in Int128Vector a, in Int128Vector b)
+            => a.X * b.X + a.Y * b.Y + a.Z * b.Z;
+    }
+
+    // === Orientation and plane-side ===
+
+    public static Int128 SignedTetrahedronVolume6(in Point p, in Point q, in Point r, in Point s)
+    {
+        var pq = Int128Vector.FromPoints(p, q);
+        var pr = Int128Vector.FromPoints(p, r);
+        var ps = Int128Vector.FromPoints(p, s);
+        var cross = Int128Vector.Cross(pq, pr);
+        return Int128Vector.Dot(cross, ps);
+    }
+
+    public static Int128 TrianglePlaneOffset(in Tetrahedron.Triangle triangle, in Point point)
+        => SignedTetrahedronVolume6(triangle.P0, triangle.P1, triangle.P2, point);
+
+    public static bool IsPointOnTrianglePlane(in Tetrahedron.Triangle triangle, in Point point)
+        => TrianglePlaneOffset(triangle, point) == Zero;
+
+    public static bool IsPointOnPositiveSideOfTrianglePlane(in Tetrahedron.Triangle triangle, in Point point)
+        => TrianglePlaneOffset(triangle, point) > Zero;
+
+    public static bool IsPointOnNegativeSideOfTrianglePlane(in Tetrahedron.Triangle triangle, in Point point)
+        => TrianglePlaneOffset(triangle, point) < Zero;
+
+    public static bool ArePointsStrictlyOnSameSideOfTrianglePlane(
+        in Tetrahedron.Triangle triangle,
+        in Point firstPoint,
+        in Point secondPoint,
+        in Point thirdPoint)
+    {
+        var o0 = TrianglePlaneOffset(triangle, firstPoint);
+        if (o0 == Zero) return false;
+        var positive = o0 > Zero;
+
+        var o1 = TrianglePlaneOffset(triangle, secondPoint);
+        if (o1 == Zero || (o1 > 0) != positive) return false;
+
+        var o2 = TrianglePlaneOffset(triangle, thirdPoint);
+        if (o2 == Zero || (o2 > 0) != positive) return false;
+
+        return true;
+    }
+
+    public static bool AreTrianglesCoplanar(in Tetrahedron.Triangle first, in Tetrahedron.Triangle second)
+        => TrianglePlaneOffset(first, second.P0) == Zero &&
+           TrianglePlaneOffset(first, second.P1) == Zero &&
+           TrianglePlaneOffset(first, second.P2) == Zero;
+
+    // Plane of `planeTriangle` cuts the interior of `other` if offsets have mixed signs (ignoring zeros).
+    public static bool DoesPlaneCutTriangleInterior(in Tetrahedron.Triangle planeTriangle, in Tetrahedron.Triangle other)
+    {
+        var o0 = TrianglePlaneOffset(planeTriangle, other.P0);
+        var o1 = TrianglePlaneOffset(planeTriangle, other.P1);
+        var o2 = TrianglePlaneOffset(planeTriangle, other.P2);
+
+        var min = MinNonZero(o0, o1, o2);
+        var max = MaxNonZero(o0, o1, o2);
+        return min < Zero && max > Zero;
+    }
+
+    private static Int128 MinNonZero(params Int128[] values)
+    {
+        var found = false;
+        Int128 min = default;
+        foreach (var v in values)
+        {
+            if (v == Zero) continue;
+            if (!found) { min = v; found = true; }
+            else if (v < min) min = v;
+        }
+        return found ? min : Zero;
+    }
+
+    private static Int128 MaxNonZero(params Int128[] values)
+    {
+        var found = false;
+        Int128 max = default;
+        foreach (var v in values)
+        {
+            if (v == Zero) continue;
+            if (!found) { max = v; found = true; }
+            else if (v > max) max = v;
+        }
+        return found ? max : Zero;
+    }
+
+    // === Colinearity / on-line tests ===
+
+    public static bool ArePointsOnSameLine(in Point a, in Point b, in Point c)
+    {
+        var ab = Int128Vector.FromPoints(a, b);
+        var ac = Int128Vector.FromPoints(a, c);
+        var cross = Int128Vector.Cross(ab, ac);
+        return cross.X == 0 && cross.Y == 0 && cross.Z == 0;
+    }
+
+    public static bool IsPointOnLine(in Point lineStart, in Point lineEnd, in Point point)
+    {
+        if (!ArePointsOnSameLine(lineStart, lineEnd, point)) return false;
+        var fromStart = Int128Vector.FromPoints(lineStart, point);
+        var fromEnd = Int128Vector.FromPoints(lineEnd, point);
+        return Int128Vector.Dot(fromStart, fromEnd) <= 0;
+    }
+
+    // === Triangle-line/triangle intersection (strict and inclusive) ===
+
+    public static bool DoesLineIntersectTriangle(in Point firstPoint, in Point secondPoint, in Tetrahedron.Triangle triangle)
+    {
+        var o0 = TrianglePlaneOffset(triangle, firstPoint);
+        var o1 = TrianglePlaneOffset(triangle, secondPoint);
+
+        if (o0 == Zero && o1 == Zero)
+        {
+            if (IsPointOnTriangle(firstPoint, triangle)) return true;
+            if (IsPointOnTriangle(secondPoint, triangle)) return true;
+            return false;
+        }
+
+        if ((o0 > Zero && o1 > Zero) || (o0 < Zero && o1 < Zero)) return false;
+
+        var oAB = SignedTetrahedronVolume6(firstPoint, secondPoint, triangle.P0, triangle.P1);
+        var oBC = SignedTetrahedronVolume6(firstPoint, secondPoint, triangle.P1, triangle.P2);
+        var oCA = SignedTetrahedronVolume6(firstPoint, secondPoint, triangle.P2, triangle.P0);
+
+        if (oAB == Zero || oBC == Zero || oCA == Zero) return true;
+
+        var pos = 0; var neg = 0;
+        CountSign(oAB, ref pos, ref neg);
+        CountSign(oBC, ref pos, ref neg);
+        CountSign(oCA, ref pos, ref neg);
+        return pos == 3 || neg == 3;
+    }
+
+    public static bool DoesTriangleIntersectTriangle(in Tetrahedron.Triangle first, in Tetrahedron.Triangle second)
+    {
+        if (DoesLineIntersectTriangle(first.P0, first.P1, second)) return true;
+        if (DoesLineIntersectTriangle(first.P1, first.P2, second)) return true;
+        if (DoesLineIntersectTriangle(first.P2, first.P0, second)) return true;
+
+        if (DoesLineIntersectTriangle(second.P0, second.P1, first)) return true;
+        if (DoesLineIntersectTriangle(second.P1, second.P2, first)) return true;
+        if (DoesLineIntersectTriangle(second.P2, second.P0, first)) return true;
+
+        return false;
+    }
+
+    public static bool DoesLineIntersectTriangleInterior(in Point firstPoint, in Point secondPoint, in Tetrahedron.Triangle triangle)
+    {
+        var o0 = TrianglePlaneOffset(triangle, firstPoint);
+        var o1 = TrianglePlaneOffset(triangle, secondPoint);
+
+        if (o0 == Zero || o1 == Zero) return false; // strict plane crossing only
+        if ((o0 > Zero && o1 > Zero) || (o0 < Zero && o1 < Zero)) return false;
+
+        var oAB = SignedTetrahedronVolume6(firstPoint, secondPoint, triangle.P0, triangle.P1);
+        var oBC = SignedTetrahedronVolume6(firstPoint, secondPoint, triangle.P1, triangle.P2);
+        var oCA = SignedTetrahedronVolume6(firstPoint, secondPoint, triangle.P2, triangle.P0);
+
+        if (oAB == Zero || oBC == Zero || oCA == Zero) return false; // edge/vertex only => boundary only
+
+        var pos = 0; var neg = 0;
+        CountSign(oAB, ref pos, ref neg);
+        CountSign(oBC, ref pos, ref neg);
+        CountSign(oCA, ref pos, ref neg);
+        return pos == 3 || neg == 3;
+    }
+
+    public static bool DoTrianglesIntersectInterior(in Tetrahedron.Triangle first, in Tetrahedron.Triangle second)
+    {
+        if (DoesLineIntersectTriangleInterior(first.P0, first.P1, second)) return true;
+        if (DoesLineIntersectTriangleInterior(first.P1, first.P2, second)) return true;
+        if (DoesLineIntersectTriangleInterior(first.P2, first.P0, second)) return true;
+
+        if (DoesLineIntersectTriangleInterior(second.P0, second.P1, first)) return true;
+        if (DoesLineIntersectTriangleInterior(second.P1, second.P2, first)) return true;
+        if (DoesLineIntersectTriangleInterior(second.P2, second.P0, first)) return true;
+
+        if (IsPointInTriangleInterior(first.P0, second)) return true;
+        if (IsPointInTriangleInterior(first.P1, second)) return true;
+        if (IsPointInTriangleInterior(first.P2, second)) return true;
+        if (IsPointInTriangleInterior(second.P0, first)) return true;
+        if (IsPointInTriangleInterior(second.P1, first)) return true;
+        if (IsPointInTriangleInterior(second.P2, first)) return true;
+
+        return false;
+    }
+
+    public static bool DoTrianglesTouchBoundaryOnly(in Tetrahedron.Triangle first, in Tetrahedron.Triangle second)
+        => DoesTriangleIntersectTriangle(first, second) && !DoTrianglesIntersectInterior(first, second);
+
+    // === Triangle interior membership (strict and inclusive) ===
+
+    public static bool IsPointInTriangleInclusive(in Point point, in Tetrahedron.Triangle triangle)
+    {
+        if (!IsPointOnTrianglePlane(triangle, point)) return false;
+        var p = ToVector3(point);
+        return IsPointInTriangleInclusive(p, triangle);
+    }
+
+    public static bool IsPointInTriangleInterior(in Point point, in Tetrahedron.Triangle triangle)
+    {
+        if (!IsPointOnTrianglePlane(triangle, point)) return false;
+        var p = ToVector3(point);
+        return IsPointInTriangleInterior(p, triangle);
+    }
+
+    private static Vector3 ToVector3(in Point p) => new((float)p.X, (float)p.Y, (float)p.Z);
+
+    private static bool IsPointInTriangleInclusive(in Vector3 p, in Tetrahedron.Triangle tri)
+    {
+        var a = ToVector3(tri.P0);
+        var b = ToVector3(tri.P1);
+        var c = ToVector3(tri.P2);
+        var n = Vector3.Cross(b - a, c - a);
+        if (n.LengthSquared() <= 0) return false;
+        var c0 = Vector3.Dot(Vector3.Cross(b - a, p - a), n);
+        var c1 = Vector3.Dot(Vector3.Cross(c - b, p - b), n);
+        var c2 = Vector3.Dot(Vector3.Cross(a - c, p - c), n);
+        return c0 >= 0 && c1 >= 0 && c2 >= 0;
+    }
+
+    private static bool IsPointInTriangleInterior(in Vector3 p, in Tetrahedron.Triangle tri)
+    {
+        var a = ToVector3(tri.P0);
+        var b = ToVector3(tri.P1);
+        var c = ToVector3(tri.P2);
+        var n = Vector3.Cross(b - a, c - a);
+        if (n.LengthSquared() <= 0) return false;
+        var c0 = Vector3.Dot(Vector3.Cross(b - a, p - a), n);
+        var c1 = Vector3.Dot(Vector3.Cross(c - b, p - b), n);
+        var c2 = Vector3.Dot(Vector3.Cross(a - c, p - c), n);
+        return c0 > 0 && c1 > 0 && c2 > 0;
+    }
+
+    private static bool IsPointOnTriangle(in Point point, in Tetrahedron.Triangle triangle)
+        => IsPointOnLine(triangle.P0, triangle.P1, point) ||
+           IsPointOnLine(triangle.P1, triangle.P2, point) ||
+           IsPointOnLine(triangle.P2, triangle.P0, point);
+
+    private static void CountSign(Int128 value, ref int positive, ref int negative)
+    {
+        if (value > Zero) positive++;
+        else if (value < Zero) negative++;
+    }
+
+    // === Visibility helper ===
+    public static bool IsTriangleFullyOnPositiveSideOfTrianglePlane(
+        in Tetrahedron.Triangle planeTriangle,
+        in Tetrahedron.Triangle other,
+        bool strict = true)
+    {
+        var o0 = TrianglePlaneOffset(planeTriangle, other.P0);
+        var o1 = TrianglePlaneOffset(planeTriangle, other.P1);
+        var o2 = TrianglePlaneOffset(planeTriangle, other.P2);
+        if (strict)
+        {
+            return o0 > Zero && o1 > Zero && o2 > Zero;
+        }
+        else
+        {
+            return o0 >= Zero && o1 >= Zero && o2 >= Zero;
+        }
+    }
+
+    // Strict mutual visibility: positive side on each other's plane, not coplanar, and no plane cutting interiors.
+    public static bool AreTrianglesMutuallyVisibleStrict(in Tetrahedron.Triangle a, in Tetrahedron.Triangle b)
+    {
+        if (!IsTriangleFullyOnPositiveSideOfTrianglePlane(a, b, strict: true)) return false;
+        if (!IsTriangleFullyOnPositiveSideOfTrianglePlane(b, a, strict: true)) return false;
+        if (AreTrianglesCoplanar(a, b)) return false;
+        if (DoesPlaneCutTriangleInterior(a, b)) return false;
+        if (DoesPlaneCutTriangleInterior(b, a)) return false;
+        return true;
+    }
+}
+
*** End Patch
