    private static bool IntersectsPlane(in Triangle triangle, in Plane plane, double epsilon)
    {
        double d0 = plane.Evaluate(triangle.P0);
        double d1 = plane.Evaluate(triangle.P1);
        double d2 = plane.Evaluate(triangle.P2);

        bool allPositive = d0 > epsilon && d1 > epsilon && d2 > epsilon;
        bool allNegative = d0 < -epsilon && d1 < -epsilon && d2 < -epsilon;

        return !(allPositive || allNegative);
    }

    private static void CollectTrianglePlaneIntersections(
        in Triangle sourceTriangle,
        in Plane targetPlane,
        in Triangle targetTriangle,
        List<Vector> intersectionPoints,
        double epsilon)
    {
        AddVertexIfOnPlaneAndInside(sourceTriangle.P0, in targetPlane, in targetTriangle, intersectionPoints, epsilon);
        AddVertexIfOnPlaneAndInside(sourceTriangle.P1, in targetPlane, in targetTriangle, intersectionPoints, epsilon);
        AddVertexIfOnPlaneAndInside(sourceTriangle.P2, in targetPlane, in targetTriangle, intersectionPoints, epsilon);

        var vertices = new[] { sourceTriangle.P0, sourceTriangle.P1, sourceTriangle.P2 };

        for (int i = 0; i < 3; i++)
        {
            var start = vertices[i];
            var end = vertices[(i + 1) % 3];

            double distanceStart = targetPlane.Evaluate(start);
            double distanceEnd = targetPlane.Evaluate(end);

            if (distanceStart > epsilon && distanceEnd > epsilon) continue;
            if (distanceStart < -epsilon && distanceEnd < -epsilon) continue;

            bool hasOppositeSigns =
                (distanceStart > epsilon && distanceEnd < -epsilon) ||
                (distanceStart < -epsilon && distanceEnd > epsilon);

            if (!hasOppositeSigns)
            {
                continue;
            }

            double t = distanceStart / (distanceStart - distanceEnd);

            var startVector = ToVector(start);
            var endVector = ToVector(end);

            var intersectionPoint = new Vector(
                startVector.X + t * (endVector.X - startVector.X),
                startVector.Y + t * (endVector.Y - startVector.Y),
                startVector.Z + t * (endVector.Z - startVector.Z));

            if (IsPointInTriangle(intersectionPoint, in targetTriangle, epsilon))
            {
                AddUniqueIntersectionPoint(intersectionPoints, in intersectionPoint);
            }
        }
    }

    private static void AddVertexIfOnPlaneAndInside(
        in Point vertex,
        in Plane targetPlane,
        in Triangle targetTriangle,
        List<Vector> intersectionPoints,
        double epsilon)
    {
        double distance = targetPlane.Evaluate(vertex);
        if (Math.Abs(distance) > epsilon)
        {
            return;
        }

        var vertexVector = ToVector(vertex);
        if (IsPointInTriangle(vertexVector, in targetTriangle, epsilon))
        {
            AddUniqueIntersectionPoint(intersectionPoints, in vertexVector);
        }
    }

    private static Vector ToVector(in Point point)
        => new Vector(point.X, point.Y, point.Z);

    // 3D barycentric point-in-triangle test aligned with
    // Geometry.Predicates.Internal.TriangleNonCoplanarIntersection.
    // Edge vectors, dot products, and epsilon usage follow the
    // same pattern so that feature construction does not diverge
    // from the predicate layer.
    private static bool IsPointInTriangle(
        in Vector point,
        in Triangle triangle,
        double epsilon)
    {
        var a = ToVector(triangle.P0);
        var b = ToVector(triangle.P1);
        var c = ToVector(triangle.P2);

        var v0 = b - a;
        var v1 = c - a;
        var v2 = point - a;

        double d00 = v0.Dot(v0);
        double d01 = v0.Dot(v1);
        double d11 = v1.Dot(v1);
        double d20 = v2.Dot(v0);
        double d21 = v2.Dot(v1);

        double denom = d00 * d11 - d01 * d01;
        if (Math.Abs(denom) < epsilon)
        {
            return false;
        }

        double invDenom = 1.0 / denom;
        double v = (d11 * d20 - d01 * d21) * invDenom;
        double w = (d00 * d21 - d01 * d20) * invDenom;
        double u = 1.0 - v - w;

        if (u < -epsilon || v < -epsilon || w < -epsilon)
        {
            return false;
        }

        return true;
    }

    private static void AddUniqueWorldPoint(
        List<Vector> points,
        in Vector candidate)
    {
        double squaredEpsilon = WorldDistanceEpsilonSquared;
        for (int i = 0; i < points.Count; i++)
        {
            var existing = points[i];
            double dx = existing.X - candidate.X;
            double dy = existing.Y - candidate.Y;
            double dz = existing.Z - candidate.Z;
            double squaredDistance = dx * dx + dy * dy + dz * dz;
            if (squaredDistance <= squaredEpsilon)
            {
                return;
            }
        }

        points.Add(candidate);
    }
}
